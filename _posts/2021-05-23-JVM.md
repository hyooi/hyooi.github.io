---
layout: post
title:  "JVM"
categories:
- Java
tags:
- JVM
---

### 1. JVM
JVM은 **자바 바이트코드를 실행할 수 있는 프로그램**이다.

플랫폼에 독립적이므로 <ins>운영체제에 무관하게 프로그램을 실행</ins>할 수 있다는 점이 특징이다.

<br/>

### 2. 메모리 구조
![image](/assets/images/jvm_heap.png)
위와 같이, JVM메모리는 크게 Heap과 Thread stack으로 이루어진다.
[JVM메모리 사용](https://speakerdeck.com/deepu105/jvm-memory-usage-stack-vs-heap)를 표현한 영상을 첨부한다.

<br/>

#### 2.1. Heap메모리
JVM은 <ins>new와 같은 키워드를 통해 오브젝트를 생성하면 이를 heap에 할당</ins>한다.
때문에 가장 큰 메모리 영역이며 일반적으로 가비지컬렉션이라고 부르는 작업이 여기서 일어난다.

JVM은 메모리를 재사용하기 위해 가비지컬렉션을 실행하는데, 이런 작업에도 불구하고 메모리가 부족하면 
흔히 말하는 **Out of Memory Error**가 발생하게 된다.

이 때 사용하는 heap메모리는 java프로그램 기동 시, Xmx, Xms변수를 통해 제한 가능하다.
```bash
java -jar -Xms2m -Xmx64m //힙을 2MB ~ 64MB까지만 사용함
```
<br/>
  
##### 2.1.1. Young영역
해당 영역의 객체가 사라질 때 <ins>Minor GC가 발생</ins>했다고 부른다.

또한, 해당 영역은 또다시 두가지 영역으로 나뉜다. 
1. eden: **객체 처음 생성됐을 때 할당**된다. eden이 일정 비율 이상 차면 설정에 따라 가비지 컬렉션이 발생한다.
2. survivor: eden에서 살아남은 객체들은 해당 영역으로 이동한다. 
이 때 survivor영역의 상태를 검사해 다른 한쪽으로 이동시키므로 둘 중 하나는 항상 비어있게 된다. (S0이나 S1에만 데이터가 있어야 정상)

<br/>

##### 2.1.2. Old영역
**Minor gc가 계속 일어났음에도 살아남은 객체**들이 저장된다.

대부분 Young영역보다 크게 할당하며, 크기가 큰 만큼 GC는 적게 발생한다. 
해당 영역의 GC를 <ins>full gc(major gc)</ins>라고 부르며, 영역이 크기 때문에 시간은 더 오래 소요된다.

<br/>

##### 2.1.3. 가비지컬렉터 통계 확인
```bash
$ jstat -gcutil 50267
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
  0.00  75.33  24.31  22.04  98.02  95.57    169    1.732     4    0.777    2.509
```
java설치 시 내장되어있는 <var>jstat</var>명령어를 통해 가비지컬렉터의 상태를 확인할 수 있다.

<var>gcutil</var>옵션을 통해 GC통계 개요를 확인할 수 있는데,
상위처럼 Survivor0(S0)과 Survivor1(S1) 중 하나에만 메모리가 75.33% 쌓여있고,
Eden(E)에는 24.31%가 쌓여있으며, Old영역(O)은 22.04% 쌓여있다는 것을 확인할 수 있다.

또한 Young영역의 GC(YGC)는 169번 수행되었고, Old영역의 Full GC(FGC)는 4번 수행되었으며,
YGC 소요시간(YGCT)는 1.732초, FGC 소요시간(FGCT)는 0.777초 수행되었다.

GCT는 YGC와 FGC의 총합 시간을 의미한다.

<br/>

[comment]: <> (#### 2.2. 스레드 스택)

[comment]: <> (- 메서드와 객체의 참조, 기본값 할당)

[comment]: <> (- 메서드 호출이나 for, while등의 스코프에 영향을 받으며 스코프가 종료되면 제거됨)

[comment]: <> (<br/>)

[comment]: <> (#### 2.3. Metaspace&#40;=PermGen&#41;영역)

[comment]: <> (JVM에서 실행되는데 필요한 클래스정의, String상수. 클래스로더는 class파일을 가져와 메모리에 저장)

[comment]: <> (### 3. 가비지 컬렉션)

[comment]: <> (- 기존의 메모리를 재사용하는 메커니즘)

[comment]: <> (- 작동 중인 코드에서 더 이상 참조하지 않은 메모리를 반환)

[comment]: <> (- c, c++은 malloc과 free로 수동으로 메모리를 관리)

[comment]: <> (<br/>)

[comment]: <> (#### 3.1. 작동과정)

[comment]: <> (- mark-and-sweep: 가비지 컬렉션은 실행 중인 코드에서 참조하는 객체를 확인해 live로 표시함)

[comment]: <> (- 힙에 있는 객체들을 찾아 live가 아닌 메모리 위치에 메모리를 할당할 수 있게 함)

[comment]: <> (- stop-the-world: gc 시 JVM의 모든 스레드가 정지됨&#40;GC튜닝이란 이 시간을 줄이는 것&#41;)

[comment]: <> (minor gc는 속도가 빨라 어플리케이션에 영향을 크게 미치지 않지만, major gc는 살아잇는 모든 객체를 검사해 시간이 오래 걸림.)

[comment]: <> (따라서 major gc횟수가 많다면 gc튜닝이 필요함)

[comment]: <> (* 따라서 System.gc를 직접 요청하는 것은 이롭지 않을 수 있다.)

[comment]: <> (> Mark : 사용 중인 메모리와 그렇지 않은 메모리를 식별)

[comment]: <> (> Sweep : mark단계에서 식별된 오브젝트를 삭제하는 단계)

[comment]: <> (<br/>)

[comment]: <> (#### 3.2. 장점)

[comment]: <> (- 수동으로 메모리 할당/해제하지 않아도 됨)

[comment]: <> (- Dangling pointer를 처리하지 않아도 됨)

[comment]: <> (  &#40;*dangling pointer: 객체에 대한 참조가 수정 없이 삭제되거나 할당 해제되어)

[comment]: <> (  포인터가 계속 할당 해제된 메모리를 가리킴&#41;)

[comment]: <> (- 자동 memory leak관리)

[comment]: <> (<br/>)

[comment]: <> (#### 3.3. 단점)

[comment]: <> (- jvm이 object참조의 생성, 삭제를 트래킹한 이후로, 기존 어플리케이션보다 더 많은 cpu를 사용하고,)

[comment]: <> (  더 많은 메모리를 필요로 하게됨)

[comment]: <> (- 개발자는 필요하지 않은 object를 해제하는데 사용되는 cpu시간을 제어할 수 없음)

[comment]: <> (- 일부 GC구현은 어플리케이션을 예상치 못하게 중단시킬 수 있음)

[comment]: <> (- 자동화된 메모리 관리는 적절한 수동 메모리 할당/해제보단 효율적이지 않음)

[comment]: <> (<br>)

[comment]: <> (#### 3.4. 가비지컬렉터 종류)

[comment]: <> (##### 3.4.1. Serial Garbage Collector)

[comment]: <> (- 단일 스레드에서 작동하는 가장 간단한 구현)

[comment]: <> (- 실행 시 전체 어플리케이션의 스레드를 프리징하므로, 멀티 스레드 환경에서는 좋은 방법이 아님)

[comment]: <> (- 적은 중단 시간을 필요로 하지 않는 클라이언트 스타일의 머신에서 선택됨)

[comment]: <> (- mark-sweep-compact: old영역의 live한 객체를 mark후,)

[comment]: <> (  heap의 앞부분부터 확인해 살아있는 것만 남김&#40;sweep&#41;,)

[comment]: <> (  그리고 각 객체들이 연속되게 쌓이도록 힙의 앞부분부터 채워 객체가 존재하는 부분과 없는 부분으로 나눔&#40;compaction&#41;)

[comment]: <> (  {% highlight bash %})

[comment]: <> (  java -XX:+UseSerialGC -jar Application.java)

[comment]: <> (  {% endhighlight %})

[comment]: <> (  <br>)

[comment]: <> (##### 3.4.2. Paralled Garbage Collector)

[comment]: <> (- JVM의 기본 GC. 다중 스레드를 사용해 힙 메모리를 관리)

[comment]: <> (- GC수행하는 동안 다른 어플리케이션 스레드도 프리징됨)

[comment]: <> (- 최대 가비지 컬렉션 스레드와 일시 중지시간, 처리량 및 힙 크기 지정 가능)

[comment]: <> (- Serial garbage collector와 알고리즘은 동일)

[comment]: <> ({% highlight bash %})

[comment]: <> (java -XX:+UseParallelGC -jar Application.java)

[comment]: <> (-XX : ParallelGCThreads = <N> : 가비지 컬렉션 스레드 수)

[comment]: <> (-XX : MaxGCPauseMillis = <N> : 최대 일시 중지시간)

[comment]: <> (-XX : GCTimeRatio = <N> : 최대 처리량 목표&#40;가비지컬렉션 소요 시간&#41;)

[comment]: <> (-Xmx <N> : 최대 힙 메모리 양)

[comment]: <> ({% endhighlight %})

[comment]: <> (<br>)

[comment]: <> (##### 3.4.3. CMS Garbage Collector)

[comment]: <> (- Concurrent mark sweep이라는 의미.)

[comment]: <> (- 다수의 가비지 컬렉션 스레드를 사용. 따라서 다른 gc방식보다 메모리와 cpu를 많이 사용)

[comment]: <> (- 짧은 가비지 컬렉션 중단을 위해 디자인되었고, 어플리케이션을 사용하는 동안 가비지 컬렉터와)

[comment]: <> (  프로세서 리소스가 공유됨)

[comment]: <> (- 응답이 느리지만 가비지 컬렉션을 위해 응답을 중지하지 않음)

[comment]: <> (- GC가 concurrent하게 동작하므로, System.gc와 같은 명시적인 가비지 컬렉션 요청을 하는 경우)

[comment]: <> (  Concurrent Mode Failure / Interruption발생)

[comment]: <> (- 총 시간의 98% 이상이 CMS가비지 컬렉션에 사용되고, 힙의 2%미만으로 복구되면 OOM발생)

[comment]: <> (  &#40;-XX : -UseGCOverheadLimit으로 비활성화 가능&#41;)

[comment]: <> (- Java9부터 더이상 사용X, Java14부터 미지원)

[comment]: <> (- compaction단계가 기본적으로 제공되지 않아, 자주 실행해야 하는 경우 다른 gc방식보다 stop-the-world시간이 길 수 있음)

[comment]: <> (  {% highlight bash %})

[comment]: <> (  java -XX:+UseParNewGC -jar Application.java)

[comment]: <> (  {% endhighlight %})

[comment]: <> (  <br>)

[comment]: <> (##### 3.4.4. G1 Garbage Collector)

[comment]: <> (- Garbage First Garbage Collector)

[comment]: <> (- 대용량 메모리 공간이 있는 다중 프로세서 시스템에서 실행되는 어플리케이션을 위해 설계됨)

[comment]: <> (- Java7부터 지원하며, 효율성이 높아 CMS 가비지 컬렉터를 대체)

[comment]: <> (- 힙을 각 가상메모리의 인접한 범위로 구성된 동일한 사이즈의 힙 집합으로 분할.)

[comment]: <> (- 가비지 컬렉션이 수행될 때, G1은 동시에 사용 중인 메모리를 marking함)

[comment]: <> (- marking이 완료되면 g1은 빈 공간을 인식하고, 빈 공간을 생성함&#40;sweeping&#41;)

[comment]: <> ({% highlight bash %})

[comment]: <> (java -XX:+UseG1GC -jar Application.java)

[comment]: <> ({% endhighlight %})

[comment]: <> (<br>)

[comment]: <> (##### 3.4.5. Z Garbage Collector)

[comment]: <> (- java11에서는 linux용 실험용으로, java14에서 읜도우 및 맥os에서 동작할 수 있도록 도입)

[comment]: <> (- java15부터 production상태)

[comment]: <> (- 스레드를 10ms이상 중지하지 않음.)

[comment]: <> (- G1과 유사하게 힙을 분할하여 처리. 8mb~16tb크기의 힙을 처리함)

[comment]: <> (  {% highlight bash %})

[comment]: <> (  -- before java15)

[comment]: <> (  java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC Application.java)

[comment]: <> (-- after java15)

[comment]: <> (java -XX:+UseZGC Application.java)

[comment]: <> ({% endhighlight %})


[comment]: <> (#### 3.5. 튜닝의 목적)

[comment]: <> (- Old generation으로 넘어가는 객체의 수 최소화)

[comment]: <> (  - old영역의 gc가 new영역의 gc보다 시간이 오래 걸리므로 객체의 수를 줄이면 full gc빈도 줄일 수 있음)

[comment]: <> (- Full GC실행시간 최소화)

[comment]: <> (  - full gc실행시간을 줄이기 위해 old영역을 줄이면, full gc횟수가 늘어남.)

[comment]: <> (    반대로 old의 크기를 늘리면 full gc횟수는 줄어들지만 실행시간이 늘어나므로 적절한 설정 필요)
  
[comment]: <> (- GC 상황 모니터링 후, 수행시간이 1~3초가 넘어가면 튜닝 진행해야 함)

[comment]: <> (- 혹은 메모리가 1,2GB로 지정했는데 OOM이 발생한다면 힙덤프로 원인 파악 후 문제점 제거)

[comment]: <> (- 24시간 이상 데이터를 수집해 GC방식, 메모리 크기를 변경해나가면서 최적의 옵션을 찾아야함)

[comment]: <> ([참조]&#40;https://d2.naver.com/helloworld/37111&#41;)
